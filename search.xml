<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>代理模式</title>
    <url>/2022/02/16/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo搭建自己的博客</title>
    <url>/2021/12/20/%E5%88%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="利用Hexo在本地搭建博客"><a href="#利用Hexo在本地搭建博客" class="headerlink" title="利用Hexo在本地搭建博客"></a>利用Hexo在本地搭建博客</h1><h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub上，是搭建博客的首选框架。大家可以进入<a href="https://hexo.io/zh-cn/">hexo官网</a>进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。尚硅谷的Git教程视频非常好，大家可以了解一下。<a href="https://www.bilibili.com/video/BV1vy4y1s7k6?spm_id_from=333.999.0.0">Git教程</a></p>
<p>windows：到git官网上下载,<a href="https://gitforwindows.org/">Download git</a>,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</p>
<p>安装好以后用<code>git --version</code>查看版本，出现版本号说明已经安装成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222091012736.png" alt="image-20211222091012736"></p>
<p>随便在计算机任何地方点击鼠标右键会出现以下选项</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222091218403.png" alt="image-20211222091218403"></p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。node.js所有版本下载地址 <a href="https://nodejs.org/zh-cn/download/releases">node.js</a>，根据自己需要下载对应的版本即可。</p>
<p>安装完后打开命令行查看版本号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222095434637.png" alt="image-20211222095434637"></p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>安装完成后用<code>hexo -v</code>查看版本。</p>
<h2 id="初始化一个博客"><a href="#初始化一个博客" class="headerlink" title="初始化一个博客"></a>初始化一个博客</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure>

<p>myblog可以自定义，实际上就是利用Hexo初始化了一个项目，myblog就是一个文件夹，接下来进入myblog安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> myblog </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>安装好之后就会有这些文件夹</p>
<ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：生成文章的一些模板</li>
<li>source：用来存放你的文章</li>
<li>themes：主题</li>
<li>** _config.yml: 博客的配置文件**</li>
</ul>
<p>然后在博客根目录下myblog目录下执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s	--hexo server的简写</span><br></pre></td></tr></table></figure>

<p>在浏览器访问<a href="localhost:4000">localhost:4000</a>就可以看到博客了，大概是这样的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/84e7c09ee0395f0faac60fdc381cd526.jpg" alt="image-20211222095434637"></p>
<p>使用Ctrl+C可以关闭服务。</p>
<h1 id="部署到Github个人仓库"><a href="#部署到Github个人仓库" class="headerlink" title="部署到Github个人仓库"></a>部署到Github个人仓库</h1><p>首先，你先要有一个GitHub账户，去注册一个吧。</p>
<p>注册完登录后，在GitHub.com中看到一个New repository，新建仓库</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222102250680.png" alt="image-20211222102250680"></p>
<p>或者</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222102315267.png" alt="image-20211222102315267"></p>
<p><span style="color:red">注意：创建仓库的名称一定要和自己的用户名一样，在加上.github.io，比如我的用户名是guyoua，那仓库名就是guyoua.github.io</span></p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222113806039.png" alt="image-20211222113806039"></p>
<h2 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h2><p>回到你的git bash中，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以用以下两条，检查一下你有没有输对</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>

<p>然后创建SSH,一路回车</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹，这个文件夹一般在 <code>C:\用户\你自己的用户名\\</code> 下面<br><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222114746571.png" alt="image-20211222114746571"></p>
<p>把公钥（<code>id_rsa.pub</code>）里面的内容复制到github上</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222115608922.png" alt="image-20211222115608922"></p>
<p>填写标题和把<code>id_rsa.pub</code>内容复制进去保存即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222115810834.png" alt="image-20211222115810834"></p>
<p>在gitbash中，查看是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<h2 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h2><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>再安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean			--清除了你之前生成的东西，也可以不加</span><br><span class="line">hexo generate		--生成静态文章，可以用 hexo g缩写</span><br><span class="line">hexo deploy			--部署文章，可以用hexo d缩写</span><br></pre></td></tr></table></figure>

<p>得到下图就说明部署成功了，过一会儿就可以在<code>http://yourname.github.io</code> 这个网站看到你的博客了！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222143203959.png" alt="image-20211222143203959"></p>
<h1 id="设置个人域名"><a href="#设置个人域名" class="headerlink" title="设置个人域名"></a>设置个人域名</h1><p>现在你的个人网站的地址是 <code>yourname.github.io</code>，可以在<a href="https://www.aliyun.com/activity/daily/award?utm_content=se_1010784590">阿里云</a>买一个域名。然后跟<code>yourname.github.io</code>绑定起来。</p>
<p>选择你刚买的域名，选择解析</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222143836537.png" alt="image-20211222143836537"></p>
<p>其中，192.30.252.153 和 192.30.252.154 是GitHub的服务器地址，解析线路选择默认。</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222144008786.png" alt="image-20211222144008786"></p>
<p>登录GitHub，进入之前创建的仓库，点击settings，点击Pages，设置Custom domain输入你的域名。</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222144308245.png" alt="image-20211222144308245"></p>
<p>然后在你的博客文件source中创建一个名为CNAME文件，不要后缀，写上你的域名。这是因为每次部署到Github上都会清空掉Custom domain，每次保存Custom domain后都会生成一个CNAME文件，所以需要在source下创建这个文件，这样部署上去就不会清空Custom domain了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222144652288.png" alt="image-20211222144652288"></p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20211222144732648.png" alt="image-20211222144732648"></p>
<p>最后，在gitbash中，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>过不了多久，再打开你的浏览器，输入你自己的域名，就可以看到搭建的网站啦！</p>
<p>新建一篇文章，在myblog目录下执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new newpapername	</span><br></pre></td></tr></table></figure>

<p>newpapername表示文件名，然后在source/_post中打开markdown文件，就可以开始编辑了，编辑完后执行以下命令再本地查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>每次需要部署到Github都需要执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<p>更多markdown语法请参照<a href="http://markdown.p2hp.com/basic-syntax/">Markdown基本语法</a></p>
]]></content>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2022/01/04/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式，顾名思义就是只有一个实例，并且它自己负责创建自己的对象，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。单例模式的写法就只有3个步骤：</p>
<ol>
<li>构造器私有化。</li>
<li>定义一个私有的类的静态实例。</li>
<li>提供一个公有的获取实例的静态方法。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220104171258594.png" alt="image-20211222091012736"></p>
<p>单例模式虽然看似简单，但是要想写好一个完美的单例模式，其中也有非常多的细节。</p>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><h4 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h4><p><strong>普通写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//提供一个静态的该类的属性</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造器私有化，防止外面可以直接new对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被new出来了&quot;</span>); <span class="comment">//每生成一个实例就打印这句话，便于测试。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 提供一个获取实例的方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@title</span>:	获取Singleton的实例对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span>: guyou</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@date</span>:  2022-01-04 17:22</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> Singleton 创建的实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">			singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式的单例模式只在需要对象的时候再创建，所以被称为懒汉式，但是这种写法有缺点：多线程的情况下还是会创建出多个实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SingletonTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> Singleton instance = Singleton.getInstance();</span><br><span class="line">                log.info(instance.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        service.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我被<span class="keyword">new</span>出来了</span><br><span class="line">我被<span class="keyword">new</span>出来了</span><br><span class="line">我被<span class="keyword">new</span>出来了</span><br><span class="line">我被<span class="keyword">new</span>出来了</span><br><span class="line"><span class="number">2022</span>-<span class="number">01</span>-<span class="number">05</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">14.206</span>  INFO <span class="number">15180</span> --- [pool-<span class="number">2</span>-thread-<span class="number">1</span>] com.guyou.test.TestApplicationTests      : com.guyou.test.test.Singleton@6a043a46</span><br><span class="line"><span class="number">2022</span>-<span class="number">01</span>-<span class="number">05</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">14.206</span>  INFO <span class="number">15180</span> --- [pool-<span class="number">2</span>-thread-<span class="number">5</span>] com.guyou.test.TestApplicationTests      : com.guyou.test.test.Singleton@55aa1a18</span><br><span class="line">我被<span class="keyword">new</span>出来了</span><br><span class="line">我被<span class="keyword">new</span>出来了</span><br><span class="line">我被<span class="keyword">new</span>出来了</span><br><span class="line">我被<span class="keyword">new</span>出来了</span><br><span class="line">我被<span class="keyword">new</span>出来了</span><br><span class="line">我被<span class="keyword">new</span>出来了</span><br><span class="line">我被<span class="keyword">new</span>出来了</span><br></pre></td></tr></table></figure>

<p>可以从日志输出看出有多个线程创建了实例对象，问题就出在创建实例对象的这个方法，因为这个方法没有加同步机制，所以会导致多线程下可能会有多个线程<code>singleton==null</code>为<code>true</code>,就会创建多个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h4><p><strong>同步方法</strong></p>
<p>我们可以在创建实例对象方法上面加上<code>synchronized</code>,如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供一个获取实例的方法,该方法为同步方法，线程安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>:	获取Singleton的实例对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guyou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:  2022-01-04 17:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Singleton 创建的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次在多线程环境下测试只有一个实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span>-<span class="number">01</span>-<span class="number">05</span> 09:<span class="number">52</span>:<span class="number">11.909</span>  INFO <span class="number">22356</span> --- [pool-<span class="number">2</span>-thread-<span class="number">5</span>] com.guyou.test.TestApplicationTests      : com.guyou.test.test.Singleton@74b5f573</span><br><span class="line"><span class="number">2022</span>-<span class="number">01</span>-<span class="number">05</span> 09:<span class="number">52</span>:<span class="number">11.909</span>  INFO <span class="number">22356</span> --- [pool-<span class="number">2</span>-thread-<span class="number">7</span>] com.guyou.test.TestApplicationTests      : com.guyou.test.test.Singleton@74b5f573</span><br><span class="line"><span class="number">2022</span>-<span class="number">01</span>-<span class="number">05</span> 09:<span class="number">52</span>:<span class="number">11.909</span>  INFO <span class="number">22356</span> --- [pool-<span class="number">2</span>-thread-<span class="number">3</span>] com.guyou.test.TestApplicationTests      : com.guyou.test.test.Singleton@74b5f573</span><br><span class="line"><span class="number">2022</span>-<span class="number">01</span>-<span class="number">05</span> 09:<span class="number">52</span>:<span class="number">11.909</span>  INFO <span class="number">22356</span> --- [pool-<span class="number">2</span>-thread-<span class="number">6</span>] com.guyou.test.TestApplicationTests      : com.guyou.test.test.Singleton@74b5f573</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种方式虽然实现了线程安全，但是<code>synchronized</code>是加在方法上的，导致锁粒度太大了，我们可以加在代码块里面，锁粒度就会小一下，前提不是用<code>this</code>当成锁对象，因为用了<code>this</code>其实就和加在方法上没什么区别了。</p>
<h4 id="写法三"><a href="#写法三" class="headerlink" title="写法三"></a>写法三</h4><p><strong>同步代码块</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供一个获取实例的方法，线程安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>:	获取Singleton的实例对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: guyou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:  2022-01-04 17:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Singleton 创建的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此种写法锁粒度会小一些，也可以使用其他的对象作为锁。</p>
<h4 id="写法四"><a href="#写法四" class="headerlink" title="写法四"></a>写法四</h4><p><strong>双重判断写法</strong></p>
<p>在写法三的基础上再进行优化，加入双重判断机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 提供一个获取实例的方法</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@title</span>:	获取Singleton的实例对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span>: guyou</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@date</span>:  2022-01-04 17:22</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> Singleton 创建的实例</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">            <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要使用双重判断，第二个判断可能容易理解，第二个判断就是加锁会判断对象是否为<code>null</code>，为<code>null</code>才创建对象，第一个判断是为了提高效率的，给后面的线程直接返回对象的机会，如果有线程获取到锁并创建了对象，那么后面的线程在第一个判断就直接可以返回创建好了的对象，无需再获取锁，直接返回对象。因为获取锁是消耗资源，消耗性能的。</p>
<h4 id="写法五"><a href="#写法五" class="headerlink" title="写法五"></a>写法五</h4><p><strong>双重判断加禁止指令重排序</strong></p>
<p>一般单例模式能写到写法四那种情况就差不多了，但是还有一种情况需要考虑，就是指令重排序，下面简单的说一下指令重排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line">b = b + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面这段代码经过指令重排后可能会是下面这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">b = b + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>这就是对指令重排比较简单、直观的解释。</p>
<p>现在来分析一下写法四中的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的该类的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;    <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化，防止外面可以直接new对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被new出来了&quot;</span>); <span class="comment">//每生成一个实例就打印这句话，便于测试。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@title</span>:	获取Singleton的实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: guyou</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>:  2022-01-04 17:22</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Singleton 创建的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;    <span class="comment">//2</span></span><br><span class="line">            <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();    <span class="comment">//1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如有AB两个线程当A线程执行到代码1处的时候.这个语句不是一个原子操作.它实际上分为三个步骤</p>
<ol>
<li>分配内存</li>
<li>初始化对象</li>
<li>设置变量指向刚分配的地址</li>
</ol>
<p>假如因为指令重排导致执行的顺序变为了1、3、2</p>
<p>那么假如A线程中执行完1、3之后，B线程到达代码2处，执行判断语句。发现singleton指向的是一段地址，因此直接不进入判断语句而是直接返回了一个没有初始化的空的对象。</p>
<p>为了避免这种情况我们可以在加上<code>volatile</code>来避免指令重排序，<code>volatile</code>关键字有两个作用：</p>
<ol>
<li>禁止指令重排序。</li>
<li>保证内存可见性。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的该类的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化，防止外面可以直接new对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被new出来了&quot;</span>); <span class="comment">//每生成一个实例就打印这句话，便于测试。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个获取实例的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@title</span>:	获取Singleton的实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: guyou</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>:  2022-01-04 17:22</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Singleton 创建的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式，从名字上也很好理解，就是“比较勤”，实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说。好处是没有线程安全的问题，坏处是浪费内存空间。</p>
<h4 id="写法一-1"><a href="#写法一-1" class="headerlink" title="写法一"></a>写法一</h4><p><strong>静态常量法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的该类的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化，防止外面可以直接new对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被new出来了&quot;</span>); <span class="comment">//每生成一个实例就打印这句话，便于测试。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个获取实例的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@title</span>:	获取Singleton的实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: guyou</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>:  2022-01-04 17:22</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Singleton 创建的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点:多线程下可以保证单例，但是会造成资源的浪费（不管我们需不需要这个唯一单例，它都会创建出来这个单例。如果我们根本不需要单例时，就会造成资源浪费。</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><strong>静态代码块</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的该类的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化，防止外面可以直接new对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被new出来了&quot;</span>); <span class="comment">//每生成一个实例就打印这句话，便于测试。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个获取实例的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@title</span>:	获取Singleton的实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: guyou</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>:  2022-01-04 17:22</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Singleton 创建的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将类的实例化放在静态代码块中，与上述的静态常量一致，都是在类装载时创建单例，因此优缺点一致。</p>
<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p><strong>静态内部类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化，防止外面可以直接new对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被new出来了&quot;</span>); <span class="comment">//每生成一个实例就打印这句话，便于测试。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个获取实例的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@title</span>:	获取Singleton的实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: guyou</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>:  2022-01-04 17:22</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Singleton 创建的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Singleton在加载的时候不会被实例化，而是在需要实例化时（调用getInstance()）,才会装载静态内部类，从而完成Singleton的实例化，多线程下可以实现单例。</p>
<h3 id="枚举式"><a href="#枚举式" class="headerlink" title="枚举式"></a>枚举式</h3><p>枚举式最安全的单例模式，就算是懒汉式的双重检测加<code>volatile</code>的写法也可以利用反射创建出多个实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2022/01/07/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。一般来说，xxxxxAdapter和xxxxx</p>
<p>工厂模式有分为三种：</p>
<ul>
<li>简单工厂</li>
<li>工厂方法</li>
<li>抽象工厂</li>
</ul>
<h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>拿手机为例，手机有很多品牌，比如华为、小米、苹果等。</p>
<p>首先定义一个手机的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//手机品牌</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义两种品牌的手机，分别实现手机的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为手机...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再定义一个专门生产手机的工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">(String phoneType)</span></span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (phoneType)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;xm&quot;</span> :</span><br><span class="line">                phone = <span class="keyword">new</span> HuaWeiPhone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hw&quot;</span> :</span><br><span class="line">                phone = <span class="keyword">new</span> XiaoMiPhone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PhoneFactory factory = <span class="keyword">new</span> PhoneFactory();</span><br><span class="line">        Phone xm = factory.createPhone(<span class="string">&quot;xm&quot;</span>);</span><br><span class="line">        Phone hw = factory.createPhone(<span class="string">&quot;hw&quot;</span>);</span><br><span class="line">        xm.brand();</span><br><span class="line">        hw.brand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出打印</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220107172236304.png" alt="image-20220107172236304"></p>
<p>可以看到，当我们给工厂不同的参数的时候，我们就能获得不同品牌的手机，但是有发现了一个问题，如果我们的工厂还想能生成苹果手机，那么我们就必须要改动工厂类的代码逻辑，这就违背了<a href="https://www.cnblogs.com/rmxd/p/12541911.html">开闭原则</a>。</p>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>在上面的简单工厂中，如果要创建的手机类型较多，且各个手机创建的过程不尽相同，则一个工厂类职责会变得越来越多，不符合单一职责原则。另外简单工厂也不符合开闭原则。要新增一种手机需要修改原来的工厂类。因此，工厂方法模式中，将生产各种类型的产品的工厂也做了抽象分离。我们对上面的简单工厂进行改造。<br>首先创建统一的工厂接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Phone <span class="title">createPhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再分别创建不同手机品牌的工厂，比如有小米手机工厂，华为手机工厂等等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaoMiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaWeiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>客户端测试截图</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220107172456117.png" alt="image-20220107172456117"></p>
<p>如果这时候需要我们还能生成苹果手机，就比较容易了，我们只需要再添加一个苹果手机工厂类，实现手机工厂就行了，无需再更改工厂类的代码。</p>
<p>增加苹果手机类，实现手机接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;苹果手机...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加苹果手机工厂类，实现手机工厂接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPhoneFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端测试截图</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220107172431934.png" alt="image-20220107172431934"></p>
<p>当我们有其他手机需要生产时，只需要先定义手机类，实现<code>Phone</code>接口，再定义手机工厂类，实现<code>PhoneFactory</code>接口，就能实现不用更改其他地方的代码就能生产出不同品牌的手机，完全符合<a href="https://www.cnblogs.com/rmxd/p/12541911.html">开闭原则</a>。但是还有一个问题，当我们新增一种品牌的手机时需要新增两个类，如果有很多手机品牌时，就会造成有很多类，造成类爆炸，而且当我们需要其他产品的时候，发现没有生产其他产品的工厂，此时我们可以把产品组合起来，一个工厂生产所有的产品，比如小米工厂要能生产手机和路由器。</p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>先定义一个手机产品的顶级接口，有手机的一些功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开机</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关机</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callup</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发邮件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个路由器的顶级接口，有路由器的一些功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开机</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关机</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开wifi</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openwifi</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setting</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写华为和小米的产品的4个实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为手机开机...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为手机关机...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为手机打电话...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为手机发送短信...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuWeiRouter</span> <span class="keyword">implements</span> <span class="title">Router</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为路由器开机...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为路由器关机...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openwifi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为路由器打开wifi...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为路由器设置...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机开机...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机关机...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机打电话...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机发送短信...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiRouter</span> <span class="keyword">implements</span> <span class="title">Router</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米路由器开机...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米路由器关机...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openwifi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米路由器打开wifi...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米路由器设置...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个顶级的产品接口，能生产手机和路由器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成手机</span></span><br><span class="line">    <span class="function">Phone <span class="title">phoneProduct</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成路由器</span></span><br><span class="line">    <span class="function">Router <span class="title">routerProduct</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写两个华为工厂和小米工厂的实现类，各自都实现产品接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiFactory</span> <span class="keyword">implements</span> <span class="title">ProductFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">phoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaWeiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Router <span class="title">routerProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuWeiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title">ProductFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">phoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaoMiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Router <span class="title">routerProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaoMiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端，通过 <code>ProductFactory</code>创建各自的工厂，通过工厂拿到对应的产品</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220107183755117.png" alt="image-20220107183755117"></p>
<p>看一下类图</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220107180650884.png" alt="image-20220107180650884"></p>
<p>如果这时候还想要增加产品等级机会很简单了，比如想新增一个苹果产品。我们只需要新增一个类<code>IPhoneFactory</code>实现<code>ProductFactory</code>，苹果工厂就能生产手机和路由器了，要想生产具体的苹果手机和苹果路由器还得新增一个<code>IPhone</code>手机类，和<code>IRouter</code>路由器类，分别实现<code>Phone</code>接口和<code>Router</code>接口，就可以生产具体的苹果手机和苹果路由器了。下面来看一下新增苹果产品后的类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220107181927789.png" alt="image-20220107181927789"></p>
<p>我们发现新增一个产品等级还是很容易的，但是新增一个产品族就会很难，比如我现在想要所有工程都能生产笔记本电脑，那么就会改动到<code>ProductFactory</code>接口的代码，因为这个接口现在定义了只生产手机和路由器，不能生产笔记本，相应的实现了<code>HuaWeiFactory</code>、XiaoMiFactory、IPhoneFactory也会改动，这又违背了开闭原则。所以说抽象工厂方法也会有优缺点。</p>
<p>优点：</p>
<ul>
<li>一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象（将一个系列的产品统一一起创建）。</li>
</ul>
<p>缺点：</p>
<ul>
<li>产品族扩展非常困难，要增加一个系列的某一产品，既要修改工厂抽象类里加代码，又修改具体的实现类里面加代码。</li>
<li>增加了系统的抽象性和理解难度。</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2022/02/11/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>建造者模式又叫创建者模式（Builder Pattern），是将一个复杂的对象的<strong>构建</strong>与它的<strong>表示</strong>分离，使得同样的构建过程可以创建不同的表示。创建者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。</p>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><ul>
<li>隔离复杂对象的创建和使用，相同的方法，不同的执行顺序，产生不同事件结果。</li>
<li>多个配件都可以装配到一个对象中，但产生不同的运行结果。</li>
<li>产品类非常复杂或者产品类因为调用顺序不同而产生不用结果。</li>
<li>初始化一个对象时，参数过多，或者很多参数具有默认值。</li>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象具有共性。</li>
</ul>
<h1 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h1><ul>
<li>在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。</li>
<li>用户只需要给出指定复杂对象的类型和内容。</li>
<li>建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)。</li>
</ul>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220214095028053.png" alt="image-20220214095028053"></p>
<h2 id="类图讲解"><a href="#类图讲解" class="headerlink" title="类图讲解"></a>类图讲解</h2><ul>
<li>指挥者（Director）直接和客户（Client）进行需求沟通。</li>
<li>沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）。</li>
<li>将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）。</li>
<li>各个具体建造者负责进行产品部件的构建。</li>
<li>最终构建成具体产品（Product）。</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>我们用生产共享单车的例子来更好的理解一下建造者模式。</p>
<p>产品类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//边框</span></span><br><span class="line">    <span class="keyword">private</span> Frame frame;</span><br><span class="line">    <span class="comment">//座椅</span></span><br><span class="line">    <span class="keyword">private</span> Seat seat;</span><br><span class="line">    <span class="comment">//轮胎</span></span><br><span class="line">    <span class="keyword">private</span> Tire tire;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略get、set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处边框、座椅、轮胎都采用接口的形式，更方便产品属性的扩展</p>
<p>Frame类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Frame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//材质</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">texture</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Frame实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlloyFrame</span> <span class="keyword">implements</span> <span class="title">Frame</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">texture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;合金材质...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelFrame</span> <span class="keyword">implements</span> <span class="title">Frame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">texture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;钢材质...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Seat实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dermisSeat</span> <span class="keyword">implements</span> <span class="title">Seat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">texture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真皮座椅...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">plasticSeat</span> <span class="keyword">implements</span> <span class="title">Seat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">texture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;塑料座椅...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tire实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigTire</span> <span class="keyword">implements</span> <span class="title">Tire</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">texture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大轮胎...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LittleTire</span> <span class="keyword">implements</span> <span class="title">Tire</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">texture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小轮胎...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Builder类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//名字</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造边框，框架</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造座椅</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造轮胎</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTire</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回构造好的自行车对象</span></span><br><span class="line">    <span class="function">Bicycle <span class="title">builder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Builder实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobikeBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bicycle bicycle = <span class="keyword">new</span> Bicycle();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bicycle.setName(<span class="string">&quot;摩拜单车...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bicycle.setFrame(<span class="keyword">new</span> SteelFrame());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bicycle.setSeat(<span class="keyword">new</span> dermisSeat());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bicycle.setTire(<span class="keyword">new</span> BigTire());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bicycle <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bicycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OfoBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bicycle bicycle = <span class="keyword">new</span> Bicycle();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bicycle.setName(<span class="string">&quot;ofo单车...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bicycle.setFrame(<span class="keyword">new</span> AlloyFrame());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bicycle.setSeat(<span class="keyword">new</span> plasticSeat());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bicycle.setTire(<span class="keyword">new</span> LittleTire());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bicycle <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bicycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指挥者Director类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bicycle <span class="title">builder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildName();</span><br><span class="line">        builder.buildFrame();</span><br><span class="line">        builder.buildSeat();</span><br><span class="line">        builder.buildTire();</span><br><span class="line">        <span class="keyword">return</span> builder.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试截图</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220214171230778.png" alt="image-20220214171230778"></p>
<p>上面示例是 Builder模式的常规用法，指挥者类 Director 在 Builder模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类。还有另外一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用 builder模式进行重构。</p>
<p>重构前示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String screen, String memory, String mainboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">        <span class="keyword">this</span>.screen = screen;</span><br><span class="line">        <span class="keyword">this</span>.memory = memory;</span><br><span class="line">        <span class="keyword">this</span>.mainboard = mainboard;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略get、set、toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构后的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewComputer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line">    <span class="comment">//构造器创建对象是直接抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;can’t init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有化的有参构造器，只能通过Builder类来构建NewComputer类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NewComputer</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        cpu = builder.cpu;</span><br><span class="line">        screen = builder.screen;</span><br><span class="line">        memory = builder.memory;</span><br><span class="line">        mainboard = builder.mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态内部类，决定了怎么构建NewComputer类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String screen;</span><br><span class="line">        <span class="keyword">private</span> String memory;</span><br><span class="line">        <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">cpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">            <span class="comment">//返回this方便链式调用</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">screen</span><span class="params">(String screen)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.screen = screen;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">memory</span><span class="params">(String memory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.memory = memory;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">mainboard</span><span class="params">(String mainboard)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mainboard = mainboard;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> NewComputer <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span>  NewComputer(<span class="keyword">this</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试截图</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220214173915126.png" alt="image-20220214173915126"></p>
<p>上面的示例代码只是传入四个参数，如果参数是十个甚至更多，builder 模式的优势将会更加明显，传递参数更加灵活，代码具有更高的可读性.</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul>
<li>使用建造者模式可以使客户端不必知道产品内部组成的细节。</li>
<li>具体的建造者类之间是相互独立的，这有利于系统的扩展。</li>
<li>具体的建造者相互独立，因此可以对建造的过程逐步细化，而不会对其他模块产生任何影响。</li>
</ul>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>
<h1 id="建造者模式与抽象工厂模式的比较"><a href="#建造者模式与抽象工厂模式的比较" class="headerlink" title="建造者模式与抽象工厂模式的比较"></a>建造者模式与抽象工厂模式的比较</h1><ul>
<li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 。</li>
<li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。</li>
<li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2022/02/09/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能，让原来不兼容的两个接口协同工作。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>让原来不兼容的两个接口协同工作。</p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ul>
<li>对象适配器</li>
<li>类适配器</li>
<li>接口适配器</li>
</ul>
<h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><ul>
<li>目标接口：Target，该角色把其他类转换为我们期望的接口</li>
<li>被适配者：Adaptee 原有的接口，也是希望被改变的接口</li>
<li>适配器： Adapter, 将被适配者和目标接口组合到一起的类</li>
</ul>
<h1 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h1><p>使用组合的方式，Target接口是我们需要操作的接口，我们的目标也是想让原有的接口（Adaptee ）变成我们想要的接口（Target），适配器类（Adapter）需要实现Target接口，Adapter类里面组合了原有的接口（Adaptee ），相当于我们在使用Target的时候，间接的通过适配器操作了原来的接口，而又没改动原来的接口，也可以根据实际业务包装原来的接口来适应我们的业务，这样就只改动我们自己写的适配器类，没有改动到原来的接口，也符合开闭原则。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220209171001573.png" alt="image-20220209171001573"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdaptee</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;原有的接口&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把原有的接口组合到适配器里面</span></span><br><span class="line">    <span class="keyword">private</span> ObjectAdaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(ObjectAdaptee adaptee)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试截图</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220209170847538.png" alt="image-20220209170847538"></p>
<h1 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h1><p>采用继承和实现的方式实现，需要适配器类（Adapter）继承原来的接口（Adaptee ）并且实现目标接口（Target），因为是继承，所以我们的适配器类其实就是原来的接口类型，能操作原来接口的属性和方法，再通过实际业务更改适配器类里面的业务，这样也是符合开闭原则的，因为又实现了目标接口（Target），所有就把原来的接口（Target）变成了我们想要的接口类型（Target）。</p>
<h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220209172805710.png" alt="image-20220209172805710"></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdaptee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;原有的接口2...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">extends</span> <span class="title">ObjectAdaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试截图</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220209173505686.png" alt="image-20220209173505686"></p>
<h1 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h1><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，适用于一个接口不想使用其所有的方法的情况。</p>
<h2 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h2><p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220210102530829.png" alt="image-20220210102530829"></p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectAdaptee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">happy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在AbsAdapter 我们将 ObjectAdaptee 的方法进行默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">ObjectAdaptee</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paly</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试截图</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220210094222002.png" alt="image-20220210094222002"></p>
<h1 id="双向适配器"><a href="#双向适配器" class="headerlink" title="双向适配器"></a>双向适配器</h1><p>在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器。</p>
<h2 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h2><p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220210100107397.png" alt="image-20220210100107397"></p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span>,<span class="title">Adaptee</span></span>&#123;</span><br><span class="line">	<span class="comment">//同时维持对抽象目标类和适配者的引用</span></span><br><span class="line">    <span class="keyword">private</span> Target target;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Target target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>可以让任何两个没有关联的类一起运行</li>
<li>提高了类的复用</li>
<li>增加了类的透明度</li>
<li>灵活性好</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol>
<li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</li>
<li>由于 Java 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</li>
</ol>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/2022/02/15/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>装饰器模式（Decorator Pattern），又称包装器模式（Wrapper Pattern）：允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220215114358212.png" alt="image-20220215114358212"></p>
<h1 id="类图说明"><a href="#类图说明" class="headerlink" title="类图说明"></a>类图说明</h1><ul>
<li>抽象构件（<code>Shape</code>）：可以是一个接口或者抽象类，充当被装饰类的原始对象，规定了被装饰类的行为。</li>
<li>具体构件（<code>Circle</code>、<code>Rrctangle</code>）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（<code>ShapeDecorator</code>）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（<code>RedShapeDecorator</code>）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p><strong>抽象构件<code>Shape</code>接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体构件<code>Circle</code>类，实现了<code>Shape</code>接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;圆形.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体构件<code>Rrctangle</code>类，实现了<code>Shape</code>接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rrctangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;矩形.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象装饰器<code>ShapeDecorator</code>类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有抽象构件的引用</span></span><br><span class="line">    <span class="keyword">private</span> Shape shape;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape shape)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shape = shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw调用前的处理....&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此处调用接口的draw方法，</span></span><br><span class="line"><span class="comment">         * 也可以在方法调用前后做附件功能的处理</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        shape.draw();</span><br><span class="line">        <span class="comment">//调用后增加一些其他的处理方法</span></span><br><span class="line">        subjoin();</span><br><span class="line">        System.out.println(<span class="string">&quot;draw调用后的处理....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装饰器扩展的方法，留给子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">subjoin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体装饰器<code>RedShapeDecorator</code>类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类构造的时候传入Shape对象，方便父类初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span><span class="params">(Shape shape)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 子类直接调用父类的draw</span></span><br><span class="line"><span class="comment">         * 如果不调用父类的draw方法</span></span><br><span class="line"><span class="comment">         * 需要重写draw方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">super</span>.draw();</span><br><span class="line">        setRedBorder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subjoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象装饰器扩展的方法.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装饰器具体实现类扩展的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedBorder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现类扩展的方法..设置红色边框......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Shape circleShape = <span class="keyword">new</span> Circle();</span><br><span class="line">    ShapeDecorator redShapeDecorator = <span class="keyword">new</span> RedShapeDecorator(circleShape);</span><br><span class="line">    redShapeDecorator.draw();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*****************************************&quot;</span>);</span><br><span class="line">    Shape rrctangleShape = <span class="keyword">new</span> Rrctangle();</span><br><span class="line">    ShapeDecorator decorator = <span class="keyword">new</span> RedShapeDecorator(rrctangleShape);</span><br><span class="line">    decorator.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试截图</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220215150608432.png" alt="image-20220215150608432"></p>
<p>具体的装饰器我们可以扩展很多，只要继承抽象的装饰器类<code>ShapeDecorator</code>就可以了。</p>
<h1 id="装饰模式的扩展"><a href="#装饰模式的扩展" class="headerlink" title="装饰模式的扩展"></a>装饰模式的扩展</h1><p>装饰模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，有时候抽象装饰器是可有可无的。</p>
<ol>
<li><p>只有一个具体装饰器，这样就不需要抽象装饰器，其结构图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220215154839034.png" alt="image-20220215154839034"></p>
</li>
<li><p>只有一个具体构件，这样就不需要抽象构件，抽象装饰者可以直接继承具体构件，其结构图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220215154850411.png" alt="image-20220215154850411"></p>
</li>
<li><p>只有一个具体构件和一个具体装饰者，这样抽象角色都不需要了，具体装饰者直接继承集体构件就可以了</p>
<p><img src="https://cdn.jsdelivr.net/gh/guyoua/static@master/imgs/image-20220215154904122.png" alt="image-20220215154904122"></p>
</li>
</ol>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul>
<li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用</li>
<li>通过使用不同装饰类及这些装饰类的排列组合，可以实现不同效果</li>
<li>装饰器模式完全遵守开闭原则</li>
</ul>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul>
<li>装饰器模式会增加许多子类，过度使用会增加程序得复杂性。</li>
</ul>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>装饰模式和代理模式的功能是雷同的，两者区别是：</p>
<ul>
<li>装饰器模式强调自身功能的扩展，是代理模式的一个特殊应用。</li>
<li>代理模式强调对代理过程的控制。</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
